{
  "_args": [
    [
      {
        "raw": "async-sema@3.0.0",
        "scope": null,
        "escapedName": "async-sema",
        "name": "async-sema",
        "rawSpec": "3.0.0",
        "spec": "3.0.0",
        "type": "version"
      },
      "/Users/Evro/Documents/Career/evro-io/evro-web-live/nextjs/evro-heroku-stage/frontend/node_modules/next"
    ]
  ],
  "_from": "async-sema@3.0.0",
  "_hasShrinkwrap": false,
  "_id": "async-sema@3.0.0",
  "_location": "/async-sema",
  "_nodeVersion": "10.3.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/async-sema_3.0.0_1551072372994_0.08934238780986647"
  },
  "_npmUser": {
    "name": "olliv",
    "email": "olli@zeit.co"
  },
  "_npmVersion": "6.1.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "async-sema@3.0.0",
    "scope": null,
    "escapedName": "async-sema",
    "name": "async-sema",
    "rawSpec": "3.0.0",
    "spec": "3.0.0",
    "type": "version"
  },
  "_requiredBy": [
    "/next"
  ],
  "_resolved": "https://registry.npmjs.org/async-sema/-/async-sema-3.0.0.tgz",
  "_shasum": "9e22d6783f0ab66a1cf330e21a905e39b3b3a975",
  "_shrinkwrap": null,
  "_spec": "async-sema@3.0.0",
  "_where": "/Users/Evro/Documents/Career/evro-io/evro-web-live/nextjs/evro-heroku-stage/frontend/node_modules/next",
  "author": {
    "name": "Olli Vanhoja"
  },
  "bugs": {
    "url": "https://github.com/zeit/async-sema/issues"
  },
  "dependencies": {},
  "description": "Semaphore using `async` and `await`",
  "devDependencies": {
    "@types/jest": "24.0.4",
    "@types/node": "11.9.3",
    "jest": "24.1.0",
    "lint-staged": "8.1.3",
    "pre-commit": "1.2.2",
    "prettier": "1.16.4",
    "ts-jest": "23.10.5",
    "typescript": "3.3.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-zyCMBDl4m71feawrxYcVbHxv/UUkqm4nKJiLu3+l9lfiQha6jQ/9dxhrXLnzzBXVFqCTDwiUkZOz9XFbdEGQsg==",
    "shasum": "9e22d6783f0ab66a1cf330e21a905e39b3b3a975",
    "tarball": "https://registry.npmjs.org/async-sema/-/async-sema-3.0.0.tgz",
    "fileCount": 5,
    "unpackedSize": 13211,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcc3x1CRA9TVsSAnZWagAA5pMP+wYUsOjq7AijPAqz637g\n7Me75SVVC3iEVxBnjTsQKKtwQoOl7Z0TMgKGJ3zBBu/8Be4ox7GR/GJ7KbyC\nNocTnZWwB7xlaDqGXEa1EgLGsbK3K6lUGsoVe8wNQG+zzW3I4aXHMX+Yvluk\nr3o2bJEdG7SSSMLokbV+zQW7bap/3BST6WijaZgnyuS0vVHfaZXjf5N6tkZL\nlYSxeNEGdnNGhNlv2Oi0fEssPTwYVVy7XlDtWxH2cKra0YThOQew68YBQylD\nWVlFhV6bUKIzGS3iekpD0oWS5u1cbeDO1qwmFmAlapndZ0ycwJOPrS3O9MQg\n92uSDYZYRgLzmM06VYqcQ0dHnxLjBTh8PvzD6q8hBIAT0nRcqkFtJqC1bZ0z\nPbhrDuxgtdMiLPQg2dD/GLLk/gT+4nrfKo6U3DuJyfB9fNPptXI6lg9e+OE/\n0WeBvDItrRRBiYlHaBg5sILX8QG5AdTXEW+9sKsMMum48vm9dCsPkehSZXG5\nrJgTH+T+U02M+rW2vqWbm/9e87QmQ7eBwsnG3F++luol1QKAocZEWe4z0R2U\ngl/9Rl1oUVGRufT9Oj6vWgwG9pt653Bos6JCUOCMHGo75BqcVr2IqVjHdp34\n0018sAODJeKPPRMkySVLFW7nLJccONNWmw5DKp6sTgOdh3V8SKymOGiKuSbD\npLxB\r\n=70ll\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "files": [
    "lib"
  ],
  "gitHead": "0b90cb8577cc8cd6b67b2c65816e1488c35360d0",
  "homepage": "https://github.com/zeit/async-sema",
  "jest": {
    "preset": "ts-jest",
    "verbose": false,
    "testURL": "http://localhost/"
  },
  "keywords": [
    "semaphore",
    "async",
    "await"
  ],
  "license": "MIT",
  "lint-staged": {
    "*.{js,ts}": [
      "prettier --write --single-quote",
      "git add"
    ]
  },
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "leo",
      "email": "leo@zeit.co"
    },
    {
      "name": "olliv",
      "email": "olli@zeit.co"
    }
  ],
  "name": "async-sema",
  "optionalDependencies": {},
  "pre-commit": "lint:staged",
  "readme": "# async-sema\n\nThis is a semaphore implementation for use with `async` and `await`. The implementation\nfollows the traditional definition of a semaphore rather than the definition of\nan asynchronous semaphore. Where as the latter one generally allows every\ndefined task to proceed immediately and synchronizes at the end, async-sema\nallows only a selected number of tasks to proceed at once while the rest will\nremain waiting.\n\nAsync-sema manages the semaphore count as a list of tokens instead of a single\nvariable containing the number of available resources. This enables an\ninteresting application of managing the actual resources with the semaphore\nobject itself. To make it practical the constructor for Sema includes an option\nfor providing an init function for the semaphore tokens. Use of a custom token\ninitializer is demonstrated in `example1.js`.\n\n## Usage\n\nFirstly, add the package to your project's `dependencies`:\n\n```bash\nnpm install --save async-sema\n```\n\nThen start using it like shown [here](./examples).\n\n## Example\nSee [/examples](./examples) for more use cases.\n\n```js\nconst { Sema } = require('async-sema');\nconst s = new Sema(\n  4, // Allow 4 concurrent async calls\n  {\n    capacity: 100 // Prealloc space for 100 tokens\n  }\n);\n\nasync function fetchData(x) {\n  await s.acquire()\n  try {\n    console.log(s.nrWaiting() + ' calls to fetch are waiting')\n    // ... do some async stuff with x\n  } finally {\n    s.release();\n  }\n}\n\nconst data = await Promise.all(array.map(fetchData));\n```\n\nThe package also offers a simple rate limiter utilizing the semaphore\nimplementation.\n\n```js\nconst { RateLimit } = require('async-sema');\n\nasync function f() {\n  const lim = RateLimit(5); // rps\n\n  for (let i = 0; i < n; i++) {\n    await lim();\n    // ... do something async\n  }\n}\n```\n\n## API\n\n### Sema\n\n#### Constructor(nr, { initFn, pauseFn, resumeFn, capacity })\n\nCreates a semaphore object. The first argument is mandatory and the second\nargument is optional.\n\n- `nr` The maximum number of callers allowed to acquire the semaphore\n  concurrently.\n- `initFn` Function that is used to initialize the tokens used to manage\n  the semaphore. The default is `() => '1'`.\n- `pauseFn` An optional fuction that is called to opportunistically request\n  pausing the the incoming stream of data, instead of piling up waiting\n  promises and possibly running out of memory.\n  See [examples/pausing.js](./examples/pausing.js).\n- `resumeFn` An optional function that is called when there is room again\n  to accept new waiters on the semaphore. This function must be declared\n  if a `pauseFn` is declared.\n- `capacity` Sets the size of the preallocated waiting list inside the\n  semaphore. This is typically used by high performance where the developer\n  can make a rough estimate of the number of concurrent users of a semaphore.\n\n#### async drain()\n\nDrains the semaphore and returns all the initialized tokens in an array.\nDraining is an ideal way to ensure there are no pending async tasks, for\nexample before a process will terminate.\n\n#### nrWaiting()\n\nReturns the number of callers waiting on the semaphore, i.e. the number of\npending promises.\n\n#### async acquire()\n\nAcquire a token from the semaphore, thus decrement the number of available\nexecution slots. If `initFn` is not used then the return value of the function\ncan be discarded.\n\n#### release(token)\n\nRelease the semaphore, thus increment the number of free execution slots. If\n`initFn` is used then the `token` returned by `acquire()` should be given as\nan argument when calling this function.\n\n### RateLimit(rps, { timeUnit, uniformDistribution })\n\nCreates a rate limiter function that blocks with a promise whenever the rate\nlimit is hit and resolves the promise once the call rate is within the limit\nset by `rps`. The second argument is optional.\n\nThe `timeUnit` is an optional argument setting the width of the rate limiting\nwindow in milliseconds. The default `timeUnit` is `1000 ms`, therefore making\nthe `rps` argument act as requests per second limit.\n\nThe `uniformDistribution` argument enforces a discrete uniform distribution over time,\ninstead of the default that allows hitting the function `rps` time and then\npausing for `timeWindow` milliseconds. Setting the `uniformDistribution`\noption is mainly useful in a situation where the flow of rate limit function\ncalls is continuous and and occuring faster than `timeUnit` (e.g. reading a\nfile) and not enabling it would cause the maximum number of calls to resolve\nimmediately (thus exhaust the limit immediately) and therefore the next bunch\ncalls would need to wait for `timeWindow` milliseconds. However if the flow is\nsparse then this option may make the\ncode run slower with no advantages.\n\n## Contributing\n\n1. [Fork](https://help.github.com/articles/fork-a-repo/) this repository to your own GitHub account and then [clone](https://help.github.com/articles/cloning-a-repository/) it to your local device\n2. Move into the directory of the clone: `cd async-sema`\n3. Link it to the global module directory of Node.js: `npm link`\n\nInside the project where you want to test your clone of the package, you can now either use `npm link async-sema` to link the clone to the local dependencies.\n\n## Author\n\nOlli Vanhoja ([@OVanhoja](https://twitter.com/OVanhoja)) - [â–²ZEIT](https://zeit.co)\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zeit/async-sema.git"
  },
  "scripts": {
    "build": "tsc",
    "lint:staged": "lint-staged",
    "prepublishOnly": "yarn build",
    "prettier": "prettier --write --single-quote './{src,test}/**/*.ts'",
    "test": "jest"
  },
  "version": "3.0.0"
}
