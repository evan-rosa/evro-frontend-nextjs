{
  "_args": [
    [
      {
        "raw": "@serverless/core@^1.0.0",
        "scope": "@serverless",
        "escapedName": "@serverless%2fcore",
        "name": "@serverless/core",
        "rawSpec": "^1.0.0",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/Users/Evro/Documents/Career/evro-io/evro-web-live/nextjs/evro-heroku-stage/frontend/node_modules/serverless-next.js"
    ]
  ],
  "_from": "@serverless/core@^1.0.0",
  "_hasShrinkwrap": false,
  "_id": "@serverless/core@1.1.2",
  "_location": "/@serverless/core",
  "_nodeVersion": "12.7.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/core_1.1.2_1571658975180_0.14120406386942164"
  },
  "_npmUser": {
    "name": "eahefnawy",
    "email": "eahefnawy@gmail.com"
  },
  "_npmVersion": "6.10.0",
  "_phantomChildren": {
    "graceful-fs": "4.2.3",
    "jsonfile": "4.0.0",
    "universalify": "0.1.2"
  },
  "_requested": {
    "raw": "@serverless/core@^1.0.0",
    "scope": "@serverless",
    "escapedName": "@serverless%2fcore",
    "name": "@serverless/core",
    "rawSpec": "^1.0.0",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/@serverless/aws-cloudfront",
    "/@serverless/aws-iam-role",
    "/@serverless/aws-lambda",
    "/@serverless/aws-lambda-layer",
    "/@serverless/aws-lambda-layer/@serverless/aws-s3",
    "/@serverless/aws-lambda/@serverless/aws-s3",
    "/@serverless/aws-s3",
    "/@serverless/domain",
    "/serverless-next.js"
  ],
  "_resolved": "https://registry.npmjs.org/@serverless/core/-/core-1.1.2.tgz",
  "_shasum": "96a2ac428d81c0459474e77db6881ebdd820065d",
  "_shrinkwrap": null,
  "_spec": "@serverless/core@^1.0.0",
  "_where": "/Users/Evro/Documents/Career/evro-io/evro-web-live/nextjs/evro-heroku-stage/frontend/node_modules/serverless-next.js",
  "author": {
    "name": "Serverless, Inc."
  },
  "dependencies": {
    "fs-extra": "^7.0.1",
    "js-yaml": "^3.13.1",
    "package-json": "^6.3.0",
    "ramda": "^0.26.1",
    "semver": "^6.1.1"
  },
  "description": "Serverless Components Core",
  "devDependencies": {
    "babel-eslint": "9.0.0",
    "eslint": "5.6.0",
    "eslint-config-prettier": "^3.6.0",
    "eslint-plugin-import": "^2.14.0",
    "eslint-plugin-prettier": "^3.0.1",
    "prettier": "^1.15.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-PY7gH+7aQ+MltcUD7SRDuQODJ9Sav9HhFJsgOiyf8IVo7XVD6FxZIsSnpMI6paSkptOB7n+0Jz03gNlEkKetQQ==",
    "shasum": "96a2ac428d81c0459474e77db6881ebdd820065d",
    "tarball": "https://registry.npmjs.org/@serverless/core/-/core-1.1.2.tgz",
    "fileCount": 36,
    "unpackedSize": 60926,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdrZzgCRA9TVsSAnZWagAAh5MP/RGyR9gIbAviIbnrkB+P\nvnVCWxfUixu+M8j1K0LcET07kG9a0cMz8BLG8bChgeI4uw4xh/NqzGiv2f0g\nBlKQW/5T5QfYqSp6J0YVVEwGOgbqRa0RSYX/2t6u1pSQJSQlhmXHO7248R7N\n8wGeFW3k7qRkyuZ8iBOVDe+j39vtZenoiWHWHnMgFEpUZsRx9yRCv7Jh3xN0\nlmEL+9UnHrgx/KQls7PW7ujrPBCQnSWbLEpp2Swg+/J2f9r4pbjKx6Sjexdr\nvAUOuQ+ZwFLwacdqYjLcjv7QDol/fZ/qtnWluJPj0y1bDGqM/58kt+yB7Mcp\nEegJtzq+wNMJRhp9Ar/mfFp5kYJSxyhIT4ENdaFbDQ2JkLyFctNvQSw3s8tf\nxgfxbAcm+8dPQfo9SPmnO1VsMkNZK1YLDOsXpU1qFROLHCCv5HFJT0PCO+bJ\nU14mdo/eqYPYLNuTDliXFrnjqwwixaMn5jLrgcc4WpsikOlKaTJAuUhB+WkO\n1pwocnjgDB1Y/JoOEu13uTrj3HJ1vFmFmbzgyBPRRbZc9vZr6bfnh+SYNdcq\nexiUCpOmK8yAV62NeuejQY+eLWWDmRJZ+ADgnMc0yjrRTtd89nKrlOHL8KcG\nt9cNFoOyTp3GU9cCAud5irwLSFHi4F0I4iIqYEjx0XSSvsfdNb7qyGJS7PmP\nnbNg\r\n=jSGX\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "16ca7f3396e868fce6a764d9b63e7afb5648becf",
  "license": "MIT",
  "main": "./src/index.js",
  "maintainers": [
    {
      "name": "ac360",
      "email": "austencollins@gmail.com"
    },
    {
      "name": "aj.stuyvenberg",
      "email": "astuyve@gmail.com"
    },
    {
      "name": "dschep",
      "email": "dschep@gmail.com"
    },
    {
      "name": "eahefnawy",
      "email": "eahefnawy@gmail.com"
    },
    {
      "name": "pmuens",
      "email": "raute1337@gmx.de"
    }
  ],
  "name": "@serverless/core",
  "optionalDependencies": {},
  "publishConfig": {
    "access": "public"
  },
  "readme": "[![Serverless Components](https://s3.amazonaws.com/assets.github.serverless/readme-serverless-components-3.gif)](http://serverless.com)\n\n<br/>\n\nBuild, compose, & deploy serverless apps in seconds with **Serverless Components**, the **[Serverless Framework's](https://github.com/serverless/serverless)** new infrastructure provisioning technology.\n\n- - [x] **Speed -** The fastest way to deploy serverless infra and apps.\n- - [x] **Power -** Deploy low-level infra, or higher-order use-case abstractions.\n- - [x] **Re-Use -** Everything you build is reusable by you, your team, and (if you want) the world.\n- - [x] **Composition -** Easily compose Components together in YAML or Javascript.\n\nHere's how easy it is to use Components with Serverless Framework:\n\n\n```yaml\n# serverless.yml\nname: website\n\nwebsite:\n  component: '@serverless/website'\n  inputs:\n    code:\n      src: ./src\n      hook: npm run build\n      domain: www.serverlesscomponents.com\n```\n\n[^ Watch a video guide on using a Serverless Component here](https://www.youtube.com/watch?v=ts26BVuX3j0).\n\n<br/>\n\n- [Quick-Start](#quick-start)\n- [Features](#features)\n- [Overview](#overview)\n- [Using Components](#using-components)\n  - [Serverless.yml Basics](#serverlessyml-basics)\n  - [Inputs](#inputs)\n  - [Outputs](#outputs)\n  - [Credentials](#credentials)\n  - [Environment Variables](#environment-variables)\n- [Building Components](#building-components)\n  - [Serverless.js Basics](#serverlessjs-basics)\n  - [Development Tips](#development-tips)\n- [Available Components](https://github.com/serverless-components)\n- [Templates](./templates)\n- [Artwork](https://github.com/serverless/artwork)\n- [Join Us on Slack](https://serverless.com/slack)\n- [Roadmap](https://github.com/serverless/components/projects/1)\n\n<br/>\n\n# Quick-Start\n\nInstall the [Serverless Framework](https://www.github.com/serverless/serverless) via NPM:\n\n```console\n$ npm i -g serverless\n```\n\n**Make sure you are using Serverless Framework version 1.49 or above.** Serverless Components Beta will not work with older versions.\n\nNext, use the `create --template-url` command to install a [Serverless Components Template](./templates), which contains Components as well as boilerplate code, to get you started quickly.\n\nHere are a few popular templates...\n\n#### [Deploy A Website](https://github.com/serverless/components/tree/master/templates/website)\n\nAWS S3 & AWS Cloudfront powered serverless website w/ custom domain. [A video guide on this can be found here](https://www.youtube.com/watch?v=ts26BVuX3j0)\n\n```shell\nserverless create --template-url https://github.com/serverless/components/tree/master/templates/website\n```\n\n#### [Deploy A REST API](https://github.com/serverless/components/tree/master/templates/backend-monolith)\n\nAWS Lambda & AWS API Gateway powered serverless REST API w/ custom domain.\n\n```shell\nserverless create --template-url https://github.com/serverless/components/tree/master/templates/backend-monolith\n```\n\n#### [Deploy A Fullstack Web Application](https://github.com/serverless/components/tree/master/templates/fullstack-application)\n\nA React-based frontend and AWS Lambda based API fullstack application.\n\n```shell\nserverless create --template-url https://github.com/serverless/components/tree/master/templates/fullstack-application\n```\n\n#### [Deploy Other Use-Cases](./templates)\n\n[Check out all of the pre-made Templates](./templates) to deploy serverless _REST APsI_, _Websockets APIs_, _Websites_, _Scheduled Tasks_, and much more! Each Template has a `README.md` with clear instructions on what it does and how to get started.\n\nAlso, all Serverless Components can be found [here](https://github.com/serverless-components/).\n\n<br/>\n\n# Features\n\n### Simplicity\n\nServerless Components are built around higher-order use-cases (e.g. a website, blog, payment system). Irrelevant low-level infrastructure details are abstracted away, and simpler configuration is offered instead.\n\nFor example, with minimal configuration, you can deploy...\n\n- A **serverless website** hosted on AWS S3, delivered globally and quickly w/ AWS Cloudfront, via a custom domain on AWS Route 53, secured by a free AWS ACM SSL Certificate:\n\n```yaml\n# serverless.yml\n\nwebsite:\n  component: '@serverless/website'\n  inputs:\n    code:\n      src: ./src\n    domain: www.serverless-app.com\n```\n\n- A **serverless API** hosted on AWS Lambda, accessible via an AWS API Gateway endpoint under a custom domain on AWS Route 53, secured by a free AWS ACM SSL Certificate:\n\n```yaml\n# serverless.yml\n\napi:\n  component: '@serverless/backend'\n  inputs:\n    code:\n      src: ./src\n    domain: api.serverless-app.com\n```\n\n- A **serverless real-time websockets API** hosted on AWS Lambda, accessible via an AWS API Gateway Websockets endpoint:\n\n  ```yaml\n  # serverless.yml\n\n  api:\n    component: '@serverless/backend-socket'\n    inputs:\n      code:\n        src: ./src\n  ```\n\n- and [much more!](./templates)\n\n### Reusability\n\nWhile Serverless Components can be easily composed in YAML (`serverless.yml`), they are written as reusable javascript libraries (`serverless.js`), with simple syntax inspired by component-based frameworks, like React.\n\n```javascript\n// serverless.js\n\nconst { Component } = require('@serverless/core')\n\nclass MyBlog extends Component {\n  async default(inputs) {\n    this.context.status('Deploying a serverless blog')\n    const website = await this.load('@serverless/website') // Load a component\n    const outputs = await website({ code: { src: './blog-code' } }) // Deploy it\n    this.state.url = outputs.url\n    await this.save()\n    return outputs\n  }\n}\n\nmodule.exports = MyBlog\n```\n\nAnyone can build a Serverless Component and share it in our upcoming Registry.\n\n### Fast Deployments\n\nMost Serverless Components deploy 20x faster than traditional cloud provisioning tools. Our intention is to design Serverless Components' that deploy almost instantly, removing the need to emulate cloud services locally.\n\n### Vendor-Agnostic\n\nServerless Components favor cloud infrastructure with serverless qualities (shocker!). We also believe in order to deliver the best product, you must be free to use the best services.\n\nServerless Components are being designed entirely vendor agnostic, enabling you to easily use services from different vendors, together! Like, AWS Lambda, AWS S3, Azure Functions, Google Big Query, Twilio, Stripe, Algolia, Cloudflare Workers and more.\n\n### Vanilla Javascript\n\nServerless Components are written in vanilla javascript and seek to use the least amount of dependencies, making the entire project as approachable as possible to beginners (and fatigued veterans).\n\n<br/>\n\n# Overview\n\nServerless Components are merely Javascript libraries that provision something/anything.\n\nThey are focused primarily on back-end use-cases, and cloud infrastructure with serverless qualities, enabling you to deliver software with radically less overhead and cost. Serverless Components are to serverless back-end use-cases, what React Components are to front-end use-cases.\n\nA Component can be designed to provision low-level infrastructure (e.g. an AWS S3 bucket). However, they can also provision higher-order outcomes — which is when they are at their best. Examples of a higher-order outcome are:\n\n1. A group of infrastructure with a purpose, like a type of data processing pipeline.\n2. A software feature, like user registration, comments, or a payment system.\n3. An entire application, like a blog, video streaming service, or landing page.\n\nThe syntax for writing a Serverless Component makes it trivial to load child Components and deploy them, enabling you to lean on low-level Components to handle difficult infrastructure provisioning tasks, while you rapidly create a higher-order abstraction.\n\nServerless Components can be used **declaratively** (via the Serverless Framework's `serverless.yml` file) or **programmatically** (via a `serverless.js` file).\n\nUsing Components declaratively is great if you want to build a serverless application as easily as possible, but not re-use it.\n\nUsing Components programmatically is also great for building serverless applications easily. And if you'd like to build a reusable Serverless Component, this is currently the only way.\n\nIn the [Using Components](#using-components) section, we'll focus on the declarative experience (`serverless.yml`). In the [Building Components](#building-components) section, we'll focus on the programmatic experience (`serverless.js`).\n\n<br/>\n\n# Using Components\n\n### Serverless.yml Basics\n\n`serverless.yml` is the easiest way to compose Serverless Components into an application.\n\nThe syntax for using Serverless Components looks like this:\n\n```yml\nname: my-serverless-website\n\nwebsite: # An instance of a component is declared here.\n  component: '@serverless/website@2.0.5' # This is the component you want to create an instance of.\n  inputs: # These are inputs to pass into the component's \"default()\" function\n    code:\n      src: ./src\n```\n\nYou can deploy this easily via the Serverless Framework with the `$ serverless` command.\n\n```console\n$ serverless # Installs and deploys the components...\n```\n\nYou can also watch for changes with the `--watch` flag\n\n```console\n$ serverless --watch # Watches for changes and redeploy if any detected\n```\n\nThere is nothing to install when using Serverless Components via `serverless.yml`. Instead, when you deploy a `serverless.yml`, its Components are downloaded automatically at the beginning of that deployment (if they aren't already downloaded), and stored in a central folder at the root of your machine. This effectively caches the Components in one location, so you don't clutter your project files with Component libraries and don't download duplicates.\n\nServerless Components are distributed via [NPM](https://www.npmjs.com/). When Components are downloaded, a basic NPM installation is happening behind the scenes.\n\nBecause of this, you use the NPM name in the `component:` property.\n\n```yml\nwebsite: # An instance of a component.\n  component: '@serverless/website' # This is the NPM package name\n```\n\nYou can also use the same semantic versioning strategy that NPM uses.\n\n```yml\nwebsite: # An instance of a component.\n  component: '@serverless/website@3.0.5' # This is the NPM package name and version\n```\n\nWhen you add a version, only that Component version is used. When you don't add a version, upon every deployment, the Serverless Framework will check for a newer version, and use that, if it exists.\n\n**Note:** While in Beta, you cannot currently use Serverless Components within an existing Serverless Framework project file (i.e. a project file that contains `functions`, `events`, `resources` and `plugins`).\n\n### Inputs\n\nEvery Serverless Component has one main function to make it deploy _something_. This is known as the `default()` function (you can learn more about it in the \"Building Components\" section). This `default()` function takes an `inputs` object.\n\nWhen you specify `inputs` for a Component in `serverless.yml`, they are simply arguments that are being passed into that Serverless Component's `default()` function.\n\n```yml\nname: my-serverless-website\n\nwebsite:\n  component: '@serverless/website@3.0.5'\n  inputs: # Inputs to pass into the component's default function\n    code:\n      src: ./src\n```\n\n### Outputs\n\nWhen a Component function (e.g. the `default()` function) is finished running, it returns an `outputs` object.\n\nYou can reference values of this `outputs` object in `serverless.yml` to pass data into Components, like this:\n\n```yml\nbackend:\n  component: '@serverless/backend@1.0.2'\n  inputs:\n    code:\n      src: ./src\n    env:\n      dbName: ${database.name}\n      dbRegion: ${database.region}\n\ndatabase:\n  component: '@serverless/aws-dynamodb@4.3.1'\n  inputs:\n    name: users-database\n```\n\nThis tells the Serverless Framework to pass a few of the outputs from the `database` instance into the `backend` instance. Specifically, the `name` and `region` of the database are being added as environment variables to the `backend` instance, so that it can interact with that database.\n\nThis also tells the Serverless Framework what depends on what. The Framework builds a graph based on this, and deploys everything in that order. Circular references however do not work and the Framework will throw an error.\n\n### Credentials\n\nUpon deployment, whether it's a `serverless.yml` or `serverless.js`, Serverless Components' core looks for a `.env` file in the current working directory.\n\nUpon deployment, if a `.env` file exists, Serverless Components will add the content of it as environment variables. If you use specific environment variable names that match that of a cloud infrastructure vendor's access keys/tokens, upon deployment, Serverless Components will automatically inject that into the Components that need that vendor to provision infrastructure.\n\nThese credentials will be used by any and all Components in your `serverless.yml` or `serverless.js` — as well as their child Components — if you specify the environment variables exactly as shown below.\n\nHere are the keys that are currently supported:\n\n#### AWS Credentials\n\n```bash\nAWS_ACCESS_KEY_ID=123456789\nAWS_SECRET_ACCESS_KEY=123456789\nAWS_REGION=us-east-1\n```\n\nComponents could access these AWS credentials using `this.context.credentials.aws`. This object would look like this:\n\n```js\n{\n  accessKeyId: '123456789',\n  secretAccessKey: '123456789',\n  region: 'us-east-1'\n}\n```\n\n#### Google Credentials\n\n```bash\n# You can specify the path to the JSON credentials file that you downloaded from Google\nGOOGLE_APPLICATION_CREDENTIALS=path/to/credentials/json/file\n\n# Or you could just provide your project id, client email & private key\nGOOGLE_PROJECT_ID=project-id-xxx\nGOOGLE_CLIENT_EMAIL=project-id-xxx@appspot.gserviceaccount.com\nGOOGLE_PRIVATE_KEY=\"-----BEGIN PRIVATE KEY-----\\nMIIEvAIBADANBgk...\"\n```\n\nComponents could access these google credentials using `this.context.credentials.google`. This object would look like this:\n\n```js\n{\n  applicationCredentials: 'path/to/credentials/json/file',\n  projectId: 'project-id-xxx',\n  clientEmail: 'project-id-xxx@appspot.gserviceaccount.com',\n  privateKey: '-----BEGIN PRIVATE KEY-----\\nMIIEvAIBADANBgk...'\n}\n```\n\n### Environment Variables\n\nYou can reference environment variables (e.g. those that you defined in the `.env` file) directly in `serverless.yml` by referencing the `${env}` object. For example, if you want to reference the `TABLE` environment variable, you could do that with `${env.TABLE}`.\n\n```yml\nbackend:\n  component: '@serverless/backend'\n  inputs:\n    code:\n      src: ./src\n    env:\n      table: ${env.TABLE}\n```\n\n<br/>\n\n# Building Components\n\nIf you want to build reusable Serverless Components, it starts and ends with a `serverless.js` file.\n\n### Serverless.js Basics\n\nIn your current working directory, install the Serverless Components core (`@serverless/core`) as a local dependency.\n\n```\nnpm i --save @serverless/core\n```\n\nCreate a `serverless.js` file, extend the Component class and add a `default` method, to make a bare minimum Serverless Component, like this:\n\n```javascript\n// serverless.js\n\nconst { Component } = require('@serverless/core')\n\nclass MyComponent extends Component {\n  async default(inputs = {}) {\n    return {}\n  } // The default functionality to run/provision/update your Component\n}\n\nmodule.exports = MyComponent\n```\n\n`default()` is always required. It is where the logic resides in order for your Component to _make_ something. Whenever you run the `$ serverless` command, it's always calling the `default()` method.\n\nYou can also any other methods to this class. A `remove()` method is often the next logical choice, if you want your Serverless Component to remove the things it creates.\n\nYou can add as many methods as you want. This is interesting because it enables you to ship more automation with your Component, than logic that merely _deploys_ and _removes_ something.\n\nYou can use the `serverless --watch` flag when you run any method. This would keep watching for changes in the current working directory, and rerun your method if changes are detected. So you could also do `serverless remove --watch` for example.\n\nIt's still early days for Serverless Components, but we are starting to work on Components that ship with their own `test()` function, or their own `logs()` and `metrics()` functions, or `seed()` for establishing initial values in a database Component. Overall, there is a lot of opportunity here to deliver outcomes that are loaded with useful automation.\n\nAll methods other than the `default()` method are optional. All methods take a single `inputs` object, not individual arguments, and return a single `outputs` object.\n\nHere is what it looks like to add a `remove` method, as well as a custom method.\n\n```javascript\n// serverless.js\n\nconst { Component } = require('@serverless/core')\n\nclass MyComponent extends Component {\n  /*\n   * Default (Required)\n   * - The default functionality to run/provision/update your Component\n   * - You can run this function by running the \"$ serverless\" command\n   */\n\n  async default(inputs = {}) {\n    return {}\n  }\n\n  /*\n   * Remove (Optional)\n   * - If your Component removes infrastructure, this is recommended.\n   * - You can run this function by running \"$ serverless remove\"\n   */\n\n  async remove(inputs = {}) {\n    return {}\n  }\n\n  /*\n   * Anything (Optional)\n   * - If you want to ship your Component w/ extra functionality, put it in a method.\n   * - You can run this function by running \"$ serverless anything\"\n   */\n\n  async anything(inputs = {}) {\n    return {}\n  }\n}\n\nmodule.exports = MyComponent\n```\n\nWhen inside a Component method, `this` comes with utilities which you can use. Here is a guide to what's available to you within the context of a Component.\n\n```javascript\n// serverless.js\n\nconst { Component } = require('@serverless/core')\n\nclass MyComponent extends Component {\n  async default(inputs = {}) {\n    // this.context features useful information\n    console.log(this.context)\n\n    // Common provider credentials are identified in the environment or .env file and added to this.context.credentials\n    // when you run \"components\", then the credentials in .env will be used\n    // when you run \"components --stage prod\", then the credentials in .env.prod will be used...etc\n    // if you don't have any .env files, then global aws credentials will be used\n    const dynamodb = new AWS.DynamoDB({ credentials: this.context.credentials.aws })\n\n    // You can easily create a random ID to name cloud infrastructure resources with using this utility.\n    const s3BucketName = `my-bucket-${this.context.resourceId()}`\n    // This prevents name collisions.\n\n    // Components have built-in state storage.\n    // Here is how to save state to your Component:\n    this.state.name = 'myComponent'\n    await this.save()\n\n    // Here is how to load a child Component.\n    // This assumes you have the \"@serverless/website\" component in your \"package.json\" file and you've run \"npm install\"\n    let website = await this.load('@serverless/website')\n\n    // You can run the default method of a child Component two ways:\n    let websiteOutputs = website({ code: { src: './src' } })\n    let websiteOutputs = website.default({ code: { src: './src' } })\n\n    // If you are deploying multiple instances of the same Component, include an instance id.\n    let website1 = await this.load('@serverless/website', 'website1')\n    let website2 = await this.load('@serverless/website', 'website2')\n\n    // Child Components save their state automatically.\n\n    // You can also load a local component that is not yet published to npm\n    // just reference the root dir that contains the serverless.js file\n    // You can also use similar syntax in serverless.yml to run local Components\n    let localComponent = await this.load('../my-local-component')\n\n    // Here is how you can easily remove a Component.\n    let websiteRemoveOutputs = await website.remove()\n\n    // Here is how you can call any custom method on a Component.\n    let websiteRemoveOutputs = await website.test({})\n\n    // If you want to show a status update to the CLI in an elegant way, use this.\n    this.context.status('Uploading')\n\n    // If you want to show a log statement in the CLI in an elegant way, use this.\n    this.context.log('this is a log statement')\n\n    // Return your results\n    return { url: websiteOutputs.url }\n  }\n}\n\nmodule.exports = MyComponent\n```\n\nJust run `serverless` in the directory that contains the `serverless.js` file to run your new component. You'll will see all the logs and outputs of your new component. Logs and outputs of any child component you use will not be shown, unless you run in debug mode: `serverless --debug`. You can also run any custom method/command you've defined with `serverless <methodName>`.\n\nFor complete real-world examples on writing components, [check out our official components](https://github.com/serverless-components)\n\n### Development Tips\n\nHere are some development tips when it comes to writing Serverless Components:\n\n#### Activate Watch Mode with the `--watch` Flag\n\nDuring development, it's super helpful to keep the terminal running with `serverless --watch` (or with any method other than the default) while you develop your component. This way you get instant feedback and reduce friction.\n\n#### Use Debug Statements and the `--debug` Flag\n\nThe Serverless Components CLI experience is intentionally minimal. But if you ever want to see what Components are doing behnd the scenes, use the `--debug` flag when you run a Component. You'll see output like this:\n\n![Serverless Components Debugging](https://s3.amazonaws.com/assets.github.serverless/components/serverless_components_debugging.png)\n\nMany Serverless Components include debug statements to report what work they are doing. We recommend you add debug statements into your Component as well. Just use this:\n\n```javascript\nclass MyComponent extends Component {\n  async default() {\n    this.context.debug(`Starting MyComponent.`)\n    this.context.debug(`Creating resources.`)\n    this.context.debug(`Waiting for resources to be provisioned.`)\n    this.context.debug(`Finished MyComponent.`)\n  }\n}\n```\n\n#### Use Local References\n\nWhen writing a Serverless Component, you can reference it locally via a `serverless.yml`, or another `serverless.js`. Keep in mind, a directory can only contain 1 `serverless.yml` or `serverless.js`. A directory cannot contain a both a `serverless.yml` and a `serverless.js`.\n\nHere's how to reference a local Component via `serverless.yml`:\n\n```yaml\nname: my-project\n\nmyComponent:\n  component: ../src\n  inputs:\n    foo: bar\n```\n\nHere's how to reference a local Component via `serverless.js`:\n\n```javascript\nclass myFirstComponent extends Component {\n  default() {\n    const mySecondComponent = this.load('../components/my-second-component')\n  }\n}\n```\n\n#### Start With The Outcome\n\nWhen making a Serverless Component, it can be tempting to break it down into several levels of child Components, to maintain separation of concerns and increase the ways your work could be re-used.\n\nHowever, provisioning back-end logic can be more complicated than designing a front-end React Component. We've learned over-optimizing for granular separation of concerns is a fast way to burn yourself out!\n\nWe recommend starting with a focus on your desired outcome. Create one Serverless Component that solves that problem first. After you've achieved your initial goal, then start breaking it down into child Components.\n\n#### The Outcome Is Your Advantage\n\nProvisioning infrastructure can be quite complicated. However, Serverless Components have one powerful advantage over general infrastructure provision tools that seek to enable every possible option and combination (e.g. AWS Cloudformation) — Serverless Components know the specific use-case they are trying to deliver.\n\nOne of the most important lessons we've learned about software development tools is that once you know the use-case, you can create a much better tool.\n\nComponents know their use-case. You can use that knowledge to: 1) provision infrastructure more reliably, because you have a clear provisioning path and you can program around the pitfalls. 2) provision infrastructure more quickly 3) add use-case specific automation to your Component in the form of custom methods.\n\n#### Keep Most State On The Cloud Provider\n\nServerless Components save remarkably little state. In fact, many powerful Components have less than 10 properties in their state objects.\n\nComponents rely on the state saved within the cloud services they use as the source of truth. This prevents drift issues that break infrastructure provisioning tools. It also opens up the possibility of working with existing resources, that were not originally managed by Serverless Components.\n\n#### Store State Immediately After A Successful Operation\n\nIf you do need to store state, try to store it immediately after a successful operation. This way, if anything after that operation fails, your Serverless Component can pick up where it left off, when the end user tries to deploy it again.\n\n#### Optimize For Accessibility\n\nWe believe serverless infrastructure and architectures will empower more people to develop software than ever before.\n\nBecause of this, we're designing all of our projects to be as approachable as possible. Please try to use simple, vanilla Javascript. Additionally, to reduce security risks and general bloat, please try to use the least amount of NPM dependencies as possible.\n",
  "readmeFilename": "README.md",
  "scripts": {
    "lint": "eslint . --fix --cache",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "1.1.2"
}
