{
  "_args": [
    [
      {
        "raw": "path-to-regexp@6.1.0",
        "scope": null,
        "escapedName": "path-to-regexp",
        "name": "path-to-regexp",
        "rawSpec": "6.1.0",
        "spec": "6.1.0",
        "type": "version"
      },
      "/Users/Evro/Documents/Career/evro-io/evro-web-live/nextjs/evro-heroku-stage/frontend/node_modules/next"
    ]
  ],
  "_from": "path-to-regexp@6.1.0",
  "_hasShrinkwrap": false,
  "_id": "path-to-regexp@6.1.0",
  "_location": "/next/path-to-regexp",
  "_nodeVersion": "13.1.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/path-to-regexp_6.1.0_1574277967326_0.3005402446223706"
  },
  "_npmUser": {
    "name": "blakeembrey",
    "email": "hello@blakeembrey.com"
  },
  "_npmVersion": "6.9.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "path-to-regexp@6.1.0",
    "scope": null,
    "escapedName": "path-to-regexp",
    "name": "path-to-regexp",
    "rawSpec": "6.1.0",
    "spec": "6.1.0",
    "type": "version"
  },
  "_requiredBy": [
    "/next"
  ],
  "_resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-6.1.0.tgz",
  "_shasum": "0b18f88b7a0ce0bfae6a25990c909ab86f512427",
  "_shrinkwrap": null,
  "_spec": "path-to-regexp@6.1.0",
  "_where": "/Users/Evro/Documents/Career/evro-io/evro-web-live/nextjs/evro-heroku-stage/frontend/node_modules/next",
  "bugs": {
    "url": "https://github.com/pillarjs/path-to-regexp/issues"
  },
  "dependencies": {},
  "description": "Express style path to RegExp utility",
  "devDependencies": {
    "@size-limit/preset-small-lib": "^2.1.6",
    "@types/jest": "^24.0.22",
    "@types/node": "^12.12.7",
    "husky": "^3.0.9",
    "jest": "^24.9.0",
    "lint-staged": "^9.4.2",
    "prettier": "^1.19.1",
    "rimraf": "^3.0.0",
    "ts-jest": "^24.1.0",
    "tslint": "^5.20.1",
    "tslint-config-prettier": "^1.18.0",
    "tslint-config-standard": "^9.0.0",
    "typescript": "^3.7.2"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-h9DqehX3zZZDCEm+xbfU0ZmwCGFCAAraPJWMXJ4+v32NjZJilVg3k1TcKsRgIb8IQ/izZSaydDc1OhJCZvs2Dw==",
    "shasum": "0b18f88b7a0ce0bfae6a25990c909ab86f512427",
    "tarball": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-6.1.0.tgz",
    "fileCount": 14,
    "unpackedSize": 476190,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJd1ZNPCRA9TVsSAnZWagAA5u0QAIPB+iLLHOaiLSK9m3gM\nS7HbJhsmxpWOEPzY+YkWMSZWEI1qpDz53JfjaMSguEZsysD9rJD28KmUoYlP\nmN95HEmjqv3z2YVbCBSeqPvCaxPx3zN6qF/NFMNTKS4ZWC/vk7zeItS60bKd\ngDnhbxVSyJP0CZTJwbMX72ELZPBNQBXJhI1vJrLDUkXBFwweTSaYhS0QClrH\nnjaTRVfKz+6KpXIjkh5r6guQNHX6cWVCahTx162wzg2gyqDt3pSI7P5WbxAr\nPabDtVZX2S+YdI5tcwLD642s1nm1GPixQ438/qwHCV/HKKWhV2av0ZHWlK2i\n+tDdw8yqKVIsp3fIv5KGbs2D+CUok+oqbFNPMzOqe1MHUJKUfY2R49EkKfjn\n+RXCEb3+9KHOsEVhZpGq+wkScepmcJ88tC9iYHvm+hyRODQbl3lWnP2hJBjw\nyGGhkSlNzfq3gH3Xn2GjA+tCvTaDo8nJbrx7L8QFR+J2yg8ERkjOzIJkVsID\nsdwWQT0oZ1j5y6mDMA0e8zP0ySgZq6rTbpGCFCLYqBiWwsR46BZaFz+r2uE1\n7ZozRC6FCplY+Ggi1rS7sIdYTqa8g6mItmhhj05kBw0sAY8rvLXKwwIczdm2\noGcvnMz79EqDSIw7FlJfZGk+PsHoRUtTKJwkezjEBwyRqxbMHj1lFO69BNDu\n0lJr\r\n=voQX\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "files": [
    "dist/",
    "dist.es2015/"
  ],
  "gitHead": "4b8efcc506ce11401919d04c40e4b316f71742da",
  "homepage": "https://github.com/pillarjs/path-to-regexp#readme",
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "jest": {
    "roots": [
      "<rootDir>/src/"
    ],
    "transform": {
      "\\.tsx?$": "ts-jest"
    },
    "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(tsx?|jsx?)$",
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "jsx",
      "json",
      "node"
    ]
  },
  "keywords": [
    "express",
    "regexp",
    "route",
    "routing"
  ],
  "license": "MIT",
  "lint-staged": {
    "*.{js,jsx,ts,tsx,json,md,yml,yaml}": [
      "npm run prettier",
      "git add"
    ]
  },
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "blakeembrey",
      "email": "hello@blakeembrey.com"
    },
    {
      "name": "defunctzombie",
      "email": "shtylman@gmail.com"
    },
    {
      "name": "dougwilson",
      "email": "doug@somethingdoug.com"
    },
    {
      "name": "jonathanong",
      "email": "jonathanrichardong@gmail.com"
    },
    {
      "name": "jongleberry",
      "email": "jonathanrichardong@gmail.com"
    }
  ],
  "module": "dist.es2015/index.js",
  "name": "path-to-regexp",
  "optionalDependencies": {},
  "publishConfig": {
    "access": "public"
  },
  "readme": "# Path-to-RegExp\n\n> Turn a path string such as `/user/:name` into a regular expression.\n\n[![NPM version][npm-image]][npm-url]\n[![Build status][travis-image]][travis-url]\n[![Test coverage][coveralls-image]][coveralls-url]\n[![Dependency Status][david-image]][david-url]\n[![License][license-image]][license-url]\n[![Downloads][downloads-image]][downloads-url]\n\n## Installation\n\n```\nnpm install path-to-regexp --save\n```\n\n## Usage\n\n```javascript\nconst { pathToRegexp, match, parse, compile } = require(\"path-to-regexp\");\n\n// pathToRegexp(path, keys?, options?)\n// match(path)\n// parse(path)\n// compile(path)\n```\n\n- **path** A string, array of strings, or a regular expression.\n- **keys** An array to populate with keys found in the path.\n- **options**\n  - **sensitive** When `true` the regexp will be case sensitive. (default: `false`)\n  - **strict** When `true` the regexp allows an optional trailing delimiter to match. (default: `false`)\n  - **end** When `true` the regexp will match to the end of the string. (default: `true`)\n  - **start** When `true` the regexp will match from the beginning of the string. (default: `true`)\n  - **delimiter** The default delimiter for segments, e.g. `[^/#?]` for `:named` patterns. (default: `'/#?'`)\n  - **endsWith** Optional character, or list of characters, to treat as \"end\" characters.\n  - **encode** A function to encode strings before inserting into `RegExp`. (default: `x => x`)\n  - **prefixes** List of characters to automatically consider prefixes when parsing. (default: `./`)\n\n```javascript\nconst keys = [];\nconst regexp = pathToRegexp(\"/foo/:bar\", keys);\n// regexp = /^\\/foo\\/([^\\/]+?)\\/?$/i\n// keys = [{ name: 'bar', prefix: '/', suffix: '', pattern: '[^\\\\/#\\\\?]+?', modifier: '' }]\n```\n\n**Please note:** The `RegExp` returned by `path-to-regexp` is intended for ordered data (e.g. pathnames, hostnames). It can not handle arbitrarily ordered data (e.g. query strings, URL fragments, JSON, etc). When using paths that contain query strings, you need to escape the question mark (`?`) to ensure it does not flag the parameter as [optional](#optional).\n\n### Parameters\n\nThe path argument is used to define parameters and populate keys.\n\n#### Named Parameters\n\nNamed parameters are defined by prefixing a colon to the parameter name (`:foo`).\n\n```js\nconst regexp = pathToRegexp(\"/:foo/:bar\");\n// keys = [{ name: 'foo', prefix: '/', ... }, { name: 'bar', prefix: '/', ... }]\n\nregexp.exec(\"/test/route\");\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n**Please note:** Parameter names must use \"word characters\" (`[A-Za-z0-9_]`).\n\n##### Custom Matching Parameters\n\nParameters can have a custom regexp, which overrides the default match (`[^/]+`). For example, you can match digits or names in a path:\n\n```js\nconst regexpNumbers = pathToRegexp(\"/icon-:foo(\\\\d+).png\");\n// keys = [{ name: 'foo', ... }]\n\nregexpNumbers.exec(\"/icon-123.png\");\n//=> ['/icon-123.png', '123']\n\nregexpNumbers.exec(\"/icon-abc.png\");\n//=> null\n\nconst regexpWord = pathToRegexp(\"/(user|u)\");\n// keys = [{ name: 0, ... }]\n\nregexpWord.exec(\"/u\");\n//=> ['/u', 'u']\n\nregexpWord.exec(\"/users\");\n//=> null\n```\n\n**Tip:** Backslashes need to be escaped with another backslash in JavaScript strings.\n\n##### Custom Prefix and Suffix\n\nParameters can be wrapped in `{}` to create custom prefixes or suffixes for your segment:\n\n```js\nconst regexp = pathToRegexp(\"/:attr1?{-:attr2}?{-:attr3}?\");\n\nregexp.exec(\"/test\");\n// => ['/test', 'test', undefined, undefined]\n\nregexp.exec(\"/test-test\");\n// => ['/test', 'test', 'test', undefined]\n```\n\n#### Unnamed Parameters\n\nIt is possible to write an unnamed parameter that only consists of a regexp. It works the same the named parameter, except it will be numerically indexed:\n\n```js\nconst regexp = pathToRegexp(\"/:foo/(.*)\");\n// keys = [{ name: 'foo', ... }, { name: 0, ... }]\n\nregexp.exec(\"/test/route\");\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n#### Modifiers\n\nModifiers must be placed after the parameter (e.g. `/:foo?`, `/(test)?`, or `/:foo(test)?`).\n\n##### Optional\n\nParameters can be suffixed with a question mark (`?`) to make the parameter optional.\n\n```js\nconst regexp = pathToRegexp(\"/:foo/:bar?\");\n// keys = [{ name: 'foo', ... }, { name: 'bar', prefix: '/', modifier: '?' }]\n\nregexp.exec(\"/test\");\n//=> [ '/test', 'test', undefined, index: 0, input: '/test', groups: undefined ]\n\nregexp.exec(\"/test/route\");\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n**Tip:** The prefix is also optional, escape the prefix `\\/` to make it required.\n\nWhen dealing with query strings, escape the question mark (`?`) so it doesn't mark the parameter as optional. Handling unordered data is outside the scope of this library.\n\n```js\nconst regexp = pathToRegexp(\"/search/:tableName\\\\?useIndex=true&term=amazing\");\n\nregexp.exec(\"/search/people?useIndex=true&term=amazing\");\n//=> [ '/search/people?useIndex=true&term=amazing', 'people', index: 0, input: '/search/people?useIndex=true&term=amazing', groups: undefined ]\n\n// This library does not handle query strings in different orders\nregexp.exec(\"/search/people?term=amazing&useIndex=true\");\n//=> null\n```\n\n##### Zero or more\n\nParameters can be suffixed with an asterisk (`*`) to denote a zero or more parameter matches.\n\n```js\nconst regexp = pathToRegexp(\"/:foo*\");\n// keys = [{ name: 'foo', prefix: '/', modifier: '*' }]\n\nregexp.exec(\"/\");\n//=> [ '/', undefined, index: 0, input: '/', groups: undefined ]\n\nregexp.exec(\"/bar/baz\");\n//=> [ '/bar/baz', 'bar/baz', index: 0, input: '/bar/baz', groups: undefined ]\n```\n\n##### One or more\n\nParameters can be suffixed with a plus sign (`+`) to denote a one or more parameter matches.\n\n```js\nconst regexp = pathToRegexp(\"/:foo+\");\n// keys = [{ name: 'foo', prefix: '/', modifier: '+' }]\n\nregexp.exec(\"/\");\n//=> null\n\nregexp.exec(\"/bar/baz\");\n//=> [ '/bar/baz','bar/baz', index: 0, input: '/bar/baz', groups: undefined ]\n```\n\n### Match\n\nThe `match` function will return a function for transforming paths into parameters:\n\n```js\n// Make sure you consistently `decode` segments.\nconst match = match(\"/user/:id\", { decode: decodeURIComponent });\n\nmatch(\"/user/123\"); //=> { path: '/user/123', index: 0, params: { id: '123' } }\nmatch(\"/invalid\"); //=> false\nmatch(\"/user/caf%C3%A9\"); //=> { path: '/user/caf%C3%A9', index: 0, params: { id: 'café' } }\n```\n\n#### Process Pathname\n\nYou should make sure variations of the same path match the expected `path`. Here's one possible solution using `encode`:\n\n```js\nconst match = match(\"/café\", { encode: encodeURI, decode: decodeURIComponent });\n\nmatch(\"/user/caf%C3%A9\"); //=> { path: '/user/caf%C3%A9', index: 0, params: { id: 'café' } }\n```\n\n**Note:** [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) automatically encodes pathnames for you.\n\n##### Alternative Using Normalize\n\nSometimes you won't have an already normalized pathname. You can normalize it yourself before processing:\n\n```js\n/**\n * Normalize a pathname for matching, replaces multiple slashes with a single\n * slash and normalizes unicode characters to \"NFC\". When using this method,\n * `decode` should be an identity function so you don't decode strings twice.\n */\nfunction normalizePathname(pathname: string) {\n  return (\n    decodeURI(pathname)\n      // Replaces repeated slashes in the URL.\n      .replace(/\\/+/g, \"/\")\n      // Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n      // Note: Missing native IE support, may want to skip this step.\n      .normalize()\n  );\n}\n\n// Two possible ways of writing `/café`:\nconst re = pathToRegexp(\"/caf\\u00E9\");\nconst input = encodeURI(\"/cafe\\u0301\");\n\nre.test(input); //=> false\nre.test(normalizePathname(input)); //=> true\n```\n\n### Parse\n\nThe `parse` function will return a list of strings and keys from a path string:\n\n```js\nconst tokens = parse(\"/route/:foo/(.*)\");\n\nconsole.log(tokens[0]);\n//=> \"/route\"\n\nconsole.log(tokens[1]);\n//=> { name: 'foo', prefix: '/', suffix: '', pattern: '[^\\\\/#\\\\?]+?', modifier: '' }\n\nconsole.log(tokens[2]);\n//=> { name: 0, prefix: '/', suffix: '', pattern: '.*', modifier: '' }\n```\n\n**Note:** This method only works with strings.\n\n### Compile (\"Reverse\" Path-To-RegExp)\n\nThe `compile` function will return a function for transforming parameters into a valid path:\n\n```js\n// Make sure you encode your path segments consistently.\nconst toPath = compile(\"/user/:id\", { encode: encodeURIComponent });\n\ntoPath({ id: 123 }); //=> \"/user/123\"\ntoPath({ id: \"café\" }); //=> \"/user/caf%C3%A9\"\ntoPath({ id: \"/\" }); //=> \"/user/%2F\"\n\ntoPath({ id: \":/\" }); //=> \"/user/%3A%2F\"\n\n// Without `encode`, you need to make sure inputs are encoded correctly.\nconst toPathRaw = compile(\"/user/:id\");\n\ntoPathRaw({ id: \"%3A%2F\" }); //=> \"/user/%3A%2F\"\ntoPathRaw({ id: \":/\" }, { validate: false }); //=> \"/user/:/\"\n\nconst toPathRepeated = compile(\"/:segment+\");\n\ntoPathRepeated({ segment: \"foo\" }); //=> \"/foo\"\ntoPathRepeated({ segment: [\"a\", \"b\", \"c\"] }); //=> \"/a/b/c\"\n\nconst toPathRegexp = compile(\"/user/:id(\\\\d+)\");\n\ntoPathRegexp({ id: 123 }); //=> \"/user/123\"\ntoPathRegexp({ id: \"123\" }); //=> \"/user/123\"\ntoPathRegexp({ id: \"abc\" }); //=> Throws `TypeError`.\ntoPathRegexp({ id: \"abc\" }, { validate: false }); //=> \"/user/abc\"\n```\n\n**Note:** The generated function will throw on invalid input.\n\n### Working with Tokens\n\nPath-To-RegExp exposes the two functions used internally that accept an array of tokens:\n\n- `tokensToRegexp(tokens, keys?, options?)` Transform an array of tokens into a matching regular expression.\n- `tokensToFunction(tokens)` Transform an array of tokens into a path generator function.\n\n#### Token Information\n\n- `name` The name of the token (`string` for named or `number` for unnamed index)\n- `prefix` The prefix string for the segment (e.g. `\"/\"`)\n- `suffix` The suffix string for the segment (e.g. `\"\"`)\n- `pattern` The RegExp used to match this token (`string`)\n- `modifier` The modifier character used for the segment (e.g. `?`)\n\n## Compatibility with Express <= 4.x\n\nPath-To-RegExp breaks compatibility with Express <= `4.x`:\n\n- RegExp special characters can only be used in a parameter\n  - Express.js 4.x supported `RegExp` special characters regardless of position - this is considered a bug\n- Parameters have suffixes that augment meaning - `*`, `+` and `?`. E.g. `/:user*`\n- No wildcard asterisk (`*`) - use parameters instead (`(.*)` or `:splat*`)\n\n## Live Demo\n\nYou can see a live demo of this library in use at [express-route-tester](http://forbeslindesay.github.com/express-route-tester/).\n\n## License\n\nMIT\n\n[npm-image]: https://img.shields.io/npm/v/path-to-regexp.svg?style=flat\n[npm-url]: https://npmjs.org/package/path-to-regexp\n[travis-image]: https://img.shields.io/travis/pillarjs/path-to-regexp.svg?style=flat\n[travis-url]: https://travis-ci.org/pillarjs/path-to-regexp\n[coveralls-image]: https://img.shields.io/coveralls/pillarjs/path-to-regexp.svg?style=flat\n[coveralls-url]: https://coveralls.io/r/pillarjs/path-to-regexp?branch=master\n[david-image]: http://img.shields.io/david/pillarjs/path-to-regexp.svg?style=flat\n[david-url]: https://david-dm.org/pillarjs/path-to-regexp\n[license-image]: http://img.shields.io/npm/l/path-to-regexp.svg?style=flat\n[license-url]: LICENSE.md\n[downloads-image]: http://img.shields.io/npm/dm/path-to-regexp.svg?style=flat\n[downloads-url]: https://npmjs.org/package/path-to-regexp\n",
  "readmeFilename": "Readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pillarjs/path-to-regexp.git"
  },
  "scripts": {
    "build": "rimraf dist/ dist.es2015/ && tsc && tsc -P tsconfig.es2015.json",
    "format": "npm run prettier -- \"{.,src/**}/*.{js,jsx,ts,tsx,json,md,yml,yaml}\"",
    "lint": "tslint \"src/**/*\" --project tsconfig.json",
    "prepare": "npm run build",
    "prettier": "prettier --write",
    "size": "size-limit",
    "specs": "jest --coverage",
    "test": "npm run build && npm run lint && npm run specs && npm run size"
  },
  "sideEffects": false,
  "size-limit": [
    {
      "path": "dist/index.js",
      "limit": "2 kB"
    }
  ],
  "typings": "dist/index.d.ts",
  "version": "6.1.0"
}
